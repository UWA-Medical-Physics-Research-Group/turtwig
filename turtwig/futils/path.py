"""
Utility functions for working with file paths
"""

import os
import re
from functools import reduce
from pathlib import Path
from typing import Callable, Generator, Iterator

import toolz as tz
import toolz.curried as curried
from fn import _

from .common import iterate_while
from .decorator import curry
from .string import placeholder_matches


@curry
def list_files(path: str, list_hidden: bool = False) -> list[str]:
    """
    Return list of full paths of files in a given path, searching through subdirectories

    Parameters
    ----------
    list_hidden: bool
        Whether to include hidden files (starting with a dot '.')

    Returns
    -------
    list[str]
        List of full paths of files in the given path

    Example
    -------
    >>> list_files("/path/")
    ["/path/file1.txt", "/path/to/dir/file2.txt", ...]
    """
    return [
        os.path.join(root, file)
        for root, _, files in os.walk(path)
        for file in files
        if list_hidden or not file.startswith(".")
    ]


@curry
def generate_full_paths(
    root: str | Path, path_generator: Callable[[str | Path], Generator[str, None, None]]
) -> Generator[str, None, None]:
    """
    Concatenate root onto paths generated by path_generator

    Parameters
    ----------
    root: str
        Root directory to concatenate onto paths
    path_generator: Callable
        Function that take ``root`` as input and returns a generator of paths

    Returns
    -------
    Generator[str, None, None]
        Generator of full paths by appending ``root`` to paths generated
        by ``path_generator``

    Example
    -------
    >>> list(generate_full_paths("/path", path_generator=os.listdir)
    ["/path/file1.txt", "/path/file2.txt", ...]
    """
    return (os.path.join(root, path) for path in path_generator(root))


@curry
def resolve_path_placeholders(path_pattern: str, placeholders: list[str]) -> list[str]:
    """
    Search directory using path_pattern and resolve placeholders with actual values

    Parameters
    ----------
    path_pattern: str
        Pattern to match directory paths, e.g. "/a/{b}/{c}"
    placeholders: list[str]
        List of placeholders to match in the pattern, e.g. ["b", "c"]

    Returns
    -------
    list[str]
        List of paths with placeholders replaced with actual values

    Example
    -------
    >>> resolve_path_placeholders("/a/{b}/{c}/d/{e}.jpg", ["b", "c"])
    ["/a/val1/val2/d/{e}.jpg", "/a/val3/val4/d/{e}.jpg", ...]
    """
    VALID_IDENTIFIER = r"[a-zA-Z0-9_]*"
    if not placeholders:
        return [path_pattern]

    def placeholder_in_list() -> Iterator[str]:
        """
        Find all placeholders in the path pattern that are in the list
        """
        return filter(
            lambda placeholder: placeholder[1:-1] in placeholders,
            re.findall(f"{{{VALID_IDENTIFIER}}}", path_pattern),
        )

    return tz.pipe(
        path_pattern,
        # Longest directory path excluding placeholders, e.g. "/a/{b}/c" -> "/a"
        iterate_while(
            os.path.dirname,
            lambda s: re.search(f"{{{VALID_IDENTIFIER}}}", s) is not None,
        ),
        list_files,
        placeholder_matches(pattern=path_pattern, placeholders=placeholders),
        # Zip matches with placeholders, e.g. for path "/a/{b}/{c}" and matches ["1"], return ("{b}", "1")
        curried.map(
            lambda matches: zip(
                placeholder_in_list(),
                matches,
            ),
        ),
        # For each match list, get string by replacing placeholders with actual values
        curried.map(
            lambda zip_matches: reduce(
                lambda path, match_: path.replace(*match_), zip_matches, path_pattern
            )
        ),
        list,
    )


def next_available_path(path: str | Path) -> Path:
    """
    Appends an integer suffix "-<int>" to the given path if it already exists, starting at 1.

    Parameters
    ----------
    path: str | Path
        Path to check for existence and append suffix if it exists

    Returns
    -------
    Path
        New path name with suffix appended if it already exists

    Example
    -------
    >>> next_available_path("/path/to/file.txt") # file.txt exists
    Path("/path/to/file-1.txt")
    >>> next_available_path("/path/to/file-1.txt") # file-1.txt exists
    Path("/path/to/file-2.txt")
    >>> next_available_path("/path/to/file-2.txt") # file-2.txt don't exist
    Path("/path/to/file-2.txt")
    """
    if not os.path.exists(path):
        return Path(path)

    base, ext = os.path.splitext(path)
    counter = iterate_while(
        _ + 1, lambda count: os.path.exists(f"{base}-{count}{ext}"), 1
    )
    return Path(f"{base}-{counter}{ext}")
